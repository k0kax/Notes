有了字节码的基础概念，接着就需要编译器取制造它。
```go
//Monkey_Compiler/compiler/compiler.go

package compiler

import (
	"monkey_Interpreter/ast"
	"monkey_Interpreter/code"
	"monkey_Interpreter/object"
)

type Compiler struct {
	instructions code.Instructions // 生成的字节码指令序列（最终交给虚拟机执行）--字节码
	constants    []object.Object   // 常量池：存储编译过程中遇到的常量（如数字、字符串）
}

func New() *Compiler {//初始化一个实例
	return &Compiler{
		instructions: code.Instructions{}, // 初始化空的字节码序列
		constants:    []object.Object{},   // 初始化空的常量池
	}
}

func (c *Compiler) Compile(node ast.Node) error {
	return nil
}

type Bytecode struct {
	Instructions code.Instructions // 字节码指令序列
	Constants    []object.Object   // 常量池（与字节码指令配套使用）
}

func (c *Compiler) Bytecode() *Bytecode {//生成字节码
	return &Bytecode{
		Instructions: c.instructions,
		Constants:    c.constants,
	}
}

```
测试代码：
```go
//Monkey_Compiler/compiler/compiler_test.go

package compiler

import (
	"fmt"
	"monkey_Interpreter/ast"
	"monkey_Interpreter/code"
	"monkey_Interpreter/lexer"
	"monkey_Interpreter/object"
	"monkey_Interpreter/parser"
	"testing"
)

// compilerTestCase 编译器测试用例结构体
// 定义“输入源码 → 预期常量池 → 预期字节码指令”的映射关系
type compilerTestCase struct {
	input               string              // 输入的Monkey语言源码（如"1+2"）
	expectedConstants   []interface{}       // 预期生成的常量池内容（如[1,2]）
	expetedInstructions []code.Instructions // 预期生成的字节码指令序列（拼写错误：应为expectedInstructions）
}

// TestIntegerArithmetic 测试整数算术表达式的编译逻辑
// 目前测试最简单的"1+2"，后续会扩展减法、乘法、除法等
func TestIntegerArithmetic(t *testing.T) {
	tests := []compilerTestCase{
		{
			input:             "1+2",               // 输入源码：1+2
			expectedConstants: []interface{}{1, 2}, // 预期常量池：[1,2]（两个整数常量）
			expetedInstructions: []code.Instructions{ // 预期字节码指令：
				code.Make(code.OpConstant, 0), // 加载常量池第0个常量（1）
				code.Make(code.OpConstant, 1), // 加载常量池第1个常量（2）
				// 注：此处缺少OpAdd指令，后续实现加法编译时会补充
			},
		},
	}
	// 执行通用的编译器测试逻辑
	runCompilerTests(t, tests)
}

// runCompilerTests 通用测试执行函数
// 封装“解析源码→编译AST→验证字节码→验证常量池”的完整流程
func runCompilerTests(t *testing.T, tests []compilerTestCase) {
	t.Helper() // 将当前函数标记为测试辅助函数，测试失败时显示调用方行号

	for _, tt := range tests {
		// 步骤1：解析输入源码，生成AST（词法分析→语法分析）
		program := parse(tt.input)

		// 步骤2：初始化编译器，编译AST生成字节码
		compiler := New()
		err := compiler.Compile(program)
		if err != nil {
			t.Fatalf("compiler error: %s", err) // 编译出错，终止测试
		}

		// 步骤3：获取编译结果（字节码+常量池）
		bytecode := compiler.Bytecode()

		// 步骤4：验证字节码指令是否符合预期
		err = testInstructions(tt.expetedInstructions, bytecode.Instructions)
		if err != nil {
			t.Fatalf("testInstructions failed: %s", err)
		}

		// 步骤5：验证常量池内容是否符合预期
		err = testConstants(tt.expectedConstants, bytecode.Constants)
		if err != nil {
			t.Fatalf("testConstants failed: %s", err)
		}
	}
}

// parse 辅助函数：将输入字符串解析为AST根节点（*ast.Program）
// 封装“词法分析→语法分析”的流程，简化测试代码
func parse(input string) *ast.Program {
	l := lexer.New(input)   // 初始化词法分析器
	p := parser.New(l)      // 初始化语法分析器
	return p.ParseProgram() // 解析生成AST程序节点
}

// testInstructions 验证实际字节码指令是否与预期一致
// 参数：
//
//	expected：预期的指令切片（每个元素是单个指令，如OpConstant 0）
//	actual：编译器生成的完整字节码指令
func testInstructions(expected []code.Instructions, actual code.Instructions) error {
	// 把预期的指令切片拼接成完整的字节数组（和实际指令格式对齐）
	concatted := concatInstructions(expected)

	// 第一步：验证指令总长度是否一致
	if len(actual) != len(concatted) {
		return fmt.Errorf("wrong instructions length.\nwant=%q\ngot=%q", concatted, actual)
	}

	// 第二步：逐字节验证指令内容是否一致
	for i, ins := range concatted {
		if actual[i] != ins {
			return fmt.Errorf("wrong instruction at %d\nwant=%q\ngot = %q", i, concatted, actual)
		}
	}
	return nil
}

// concatInstructions 辅助函数：将多个独立的指令拼接成完整的字节码序列
// 比如 [OpConstant 0, OpConstant 1] → [0,0,0,1]（假设OpConstant=0）
func concatInstructions(s []code.Instructions) code.Instructions {
	out := code.Instructions{}
	for _, ins := range s {
		out = append(out, ins...) // 逐个拼接指令字节
	}
	return out
}

// testConstants 验证实际常量池是否与预期一致
// 目前只支持验证整数类型的常量，后续可扩展字符串、函数等
func testConstants(expected []interface{}, actual []object.Object) error {
	// 第一步：验证常量池长度是否一致
	if len(expected) != len(actual) {
		return fmt.Errorf("wrong number of constants.got=%d,want=%d", len(actual), len(expected))
	}

	// 第二步：逐常量验证类型和值是否一致
	for i, constant := range expected {
		switch constant := constant.(type) {
		case int:
			// 验证整数常量的具体值
			err := testIntegerObject(int64(constant), actual[i])
			if err != nil {
				return fmt.Errorf("constant %d-testIntegerObject failed:%s", i, err)
			}
			// 后续扩展：case string: 验证字符串常量
		}
	}
	return nil
}

// testIntegerObject 辅助函数：验证常量池中的对象是否为预期的整数对象
func testIntegerObject(expected int64, actual object.Object) error {
	// 类型断言：判断实际对象是否为*object.Integer
	result, ok := actual.(*object.Integer)
	if !ok {
		return fmt.Errorf("object is not Integer. got-%T(%+v)", actual, actual)
	}

	// 验证整数值是否一致
	if result.Value != expected {
		return fmt.Errorf("object has wrong value. got=%d,want=%d", result.Value, expected)
	}
	return nil
}

```
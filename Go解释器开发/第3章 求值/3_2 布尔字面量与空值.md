## 布尔字面量
布尔型就是true和false，所有的true就是true，false亦然。故而可以固定这两个实例object
```go
//evaluator.go
package evaluator

//求值器

import (
	"monkey_Interpreter/ast"
	"monkey_Interpreter/object"
)

var (
	TRUE  = &object.Boolean{Value: true}
	FALSE = &object.Boolean{Value: false}
)

func Eval(node ast.Node) object.Object {
	switch node := node.(type) {

	//语句
	case *ast.Program:
		return evalStatements(node.Statements)

	//表达式语句
	case *ast.ExpressionStatement:
		return Eval(node.Expression)

	//整形字面量
	case *ast.IntegerLiteral:
		return &object.Integer{Value: node.Value}

	//布尔型字面量
	case *ast.Boolean:
		return nativeBoolToBooleanObject(node.Value)
	}

	return nil
}

//原始布尔型，转换成布尔对象实例
func nativeBoolToBooleanObject(input bool) *object.Boolean {
	if input {
		return TRUE
	}

	return FALSE
}

func evalStatements(stmts []ast.Statement) object.Object {
	var result object.Object

	for _, statement := range stmts {
		result = Eval(statement)
	}

	return result
}

```

测试代码
```go
//evaluator_test.go
func TestEvalBooleanExpression(t *testing.T) {
	tests := []struct {
		input    string
		expected bool
	}{
		{"true", true},
		{"false", false},
	}

	for _, tt := range tests {
		evaluated := testEval(tt.input)
		testBooleanObject(t, evaluated, tt.expected)
	}
}

func testBooleanObject(t *testing.T, obj object.Object, expected bool) bool {
	result, ok := obj.(*object.Boolean)
	if !ok {
		t.Errorf("object is not Boolean. got=%T(%+v)", obj, obj)
		return false
	}

	if result.Value != expected {
		t.Errorf("object has wrong value. got=%t, want=%t", result.Value, expected)
		return false
	}

	return true
}
```

测试repl，运行main函数
```go
PS E:\Codes\Go\monkey_Interpreter> go run .\main.go
Hello LAPTOP This is the Monkey programmimg language!
Feel freee to type in commamds
>>true
true
>>true
true
>>false
false
>>
```

## 空值
和前面类似
``

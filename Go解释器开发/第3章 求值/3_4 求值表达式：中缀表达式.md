monkey有八种中缀运算符
```go
5 + 5;
5 - 5;
5 * 5;
5 / 5;

5 > 5;
5 < 5;
5 == 5;
5 != 5;
```
这八位可以分为两组，前一组得到数值，后一组产生布尔值。对中缀表达式进行求值，无非是先求左值和右值，再将二者进行运算

给Eval函数添加中缀表达式求值方法
```go
//evaluator.go
func Eval(node ast.Node) object.Object {
	switch node := node.(type) {

	//语句
	case *ast.Program:
		return evalStatements(node.Statements)

	//表达式语句
	case *ast.ExpressionStatement:
		return Eval(node.Expression)

	//整形字面量
	case *ast.IntegerLiteral:
		return &object.Integer{Value: node.Value}

	//布尔型字面量
	case *ast.Boolean:
		return nativeBoolToBooleanObject(node.Value)

	//前缀表达式
	case *ast.PrefixExpression:
		right := Eval(node.Right)
		return evalPrefixExpression(node.Operator, right)

	//中缀表达式
	case *ast.InfixExpression:
		left := Eval(node.Left)
		right := Eval(node.Right)
		return evalInfixExpression(node.Operator, left, right)

	}

	return nil
}
```

这个evalInfixExpression函数是个中转函数，因为中缀有很多形式
```go
//evaluator.go
// 中缀表达式 中转函数
func evalInfixExpression(operator string, left, right object.Object) object.Object {
	switch {
	case left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ://左右值都是整数
		return evalIntegerInfixExpression(operator, left, right) //整数的处理
	default:
		return NULL
	}
}
```

## 纯整数中缀操作符操作
具体的中缀操作符函数
```go
//evaluator.go
// 整数的中缀操作符处理
func evalIntegerInfixExpression(operator string, left, right object.Object) object.Object {
	leftVal := left.(*object.Integer).Value   //取左值
	rightVal := right.(*object.Integer).Value //取右值

	switch operator {
	case "+":
		return &object.Integer{Value: leftVal + rightVal}
	case "-":
		return &object.Integer{Value: leftVal - rightVal}
	case "*":
		return &object.Integer{Value: leftVal * rightVal}
	case "/":
		return &object.Integer{Value: leftVal / rightVal}
	default:
		return NULL
	}
}
```

拓展测试代码
```go
// 测试表达式求值 整数操作
func TestEvalIntegerExpression(t *testing.T) {
	tests := []struct {
		input    string
		expected int64
	}{
		{"5", 5},
		{"10", 10},
		{"-5", -5},
		{"-10", -10},
		{"5 + 5 + 5 + 5 - 10", 10},
		{"2 * 2 * 2 * 2 * 2", 32},
		{"-50 + 100 + -50", 0},
		{"5 * 2 + 10", 20},
		{"5 + 2 * 10", 25},
		{"20 + 2 * -10", 0},
		{"50 / 2 * 2 + 10", 60},
		{"2 * (5 + 10)", 30},
		{"3 * 3 * 3 + 10", 37},
		{"3 * (3 * 3) + 10", 37},
		{"(5 + 10 * 2 + 15 / 3) * 2 + -10", 50},
	}

	for _, tt := range tests {
		evaluated := testEval(tt.input)
		testIntegerObject(t, evaluated, tt.expected)
	}
}
```
测试repl:
```go
PS E:\Codes\Go\monkey_Interpreter> go run .\main.go
Hello LA! This is the Monkey programmimg language!
Feel freee to type in commamds
>>1+1
2
>>4+4
8
>>(5 + 10 * 2 + 15 / 3) * 2 + -10
50
>>
```
## 布尔型中缀运算符操作

整数间的布尔型操作，仅需补充evalIntegerInfixExpression函数即可
```go
//evaluator.go
// 整数的中缀操作符处理
func evalIntegerInfixExpression(operator string, left, right object.Object) object.Object {
	leftVal := left.(*object.Integer).Value   //取左值
	rightVal := right.(*object.Integer).Value //取右值

	switch operator {
	//四则运算操作
	case "+":
		return &object.Integer{Value: leftVal + rightVal}
	case "-":
		return &object.Integer{Value: leftVal - rightVal}
	case "*":
		return &object.Integer{Value: leftVal * rightVal}
	case "/":
		return &object.Integer{Value: leftVal / rightVal}

	//布尔操作
	case "<":
		return nativeBoolToBooleanObject(leftVal < rightVal)
	case ">":
		return nativeBoolToBooleanObject(leftVal > rightVal)
	case "==":
		return nativeBoolToBooleanObject(leftVal == rightVal)
	case "!=":
		return nativeBoolToBooleanObject(leftVal != rightVal)

	default:
		return NULL
	}
}
```
true和false的操作，只需要在更高级的evalInfixExpression函数，直接通过对比左右object对象即可
```go
//evaluator.go
// 中缀表达式 中转函数
func evalInfixExpression(operator string, left, right object.Object) object.Object {
	switch {
	case left.Type() == object.INTEGER_OBJ && right.Type() == object.INTEGER_OBJ: //左右值都是整数
		return evalIntegerInfixExpression(operator, left, right) //整数的处理

	case operator == "==":
		return nativeBoolToBooleanObject(left == right)
	case operator == "!=":
		return nativeBoolToBooleanObject(left != right)

	default:
		return NULL
	}
}
```

修改测试代码
```go

```
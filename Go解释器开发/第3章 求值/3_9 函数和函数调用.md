这个有点复杂
首先，我们先看看FunctionLiteral和CallExpression的ast
```go
// -------------------------------------------函数字面量-----------------------------------
type FunctionLiteral struct {
	Token      token.Token     //fn词法单元
	Parameters []*Identifier   //形参列表
	Body       *BlockStatement //函数体
}

// -----------------------------------------------表达式（函数）调用-----------------------------
type CallExpression struct {
	Token     token.Token  //(词法单元
	Function  Expression   //被调用的函数（可以是标识符或函数字面量）
	Arguments []Expression //实参列表
}
```
函数需要形式参数，调用函数则需要实际参数，并且要绑定正确形参。

修改Function的object对象，需要为每一个函数，加上环境
```go
const (
	INTEGER_OBJ      = "INTEGER"      //整数
	BOOLEAN_OBJ      = "BOOLEAN"      //布尔
	NULL_OBJ         = "NULL"         //空值
	RETURN_VALUE_OBJ = "RETURN_VALUE" //返回值
	ERROR_OBJ        = "ERROR"        //错误
	FUNCTION_OBJ     = "FUNCTION"     //函数
)


```

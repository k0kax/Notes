# 编译原理基础核心词汇（含英文+通俗解释）
结合编译/解释器核心流程（从源代码到执行结果），整理了入门必备的基础词汇，关联 Monkey 解释器代码（如 Lexer、Token 等），方便串联理解。

## 一、核心流程与整体概念
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Compiler                     | 编译器                                                                   | 把高级语言（如 Java、C）源代码**一次性翻译成**目标代码（如机器码、字节码）的程序（全程不运行代码）。 |
| Interpreter                  | 解释器                                                                   | 把高级语言源代码**逐行解释并执行**的程序（边翻译边运行，如你的 Monkey 解释器）。   |
| Source Code                  | 源代码                                                                   | 程序员用高级语言写的原始代码（如 `let x = 42;`）。                                 |
| Target Code / Object Code    | 目标代码/目标文件                                                       | 编译器输出的、可被机器直接或间接执行的代码（如机器码、Java 字节码）。               |
| Intermediate Representation (IR) | 中间表示                                                               | 源代码翻译过程中生成的“中间代码”（介于高级语言和目标代码之间），方便优化和跨平台（如 LLVM IR）。 |
| Frontend                     | 编译前端                                                                 | 编译器/解释器的“前期处理部分”，负责**理解源代码**（词法分析、语法分析、语义分析）。 |
| Backend                      | 编译后端                                                                 | 编译器的“后期处理部分”，负责**生成目标代码**（优化、目标代码生成），依赖具体硬件平台。 |

## 二、词法分析阶段（Lexical Analysis）
（对应 Monkey 解释器的 `Lexer`，核心是“拆字符串为 Token”）
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Lexical Analysis / Scanning  | 词法分析/扫描                                                           | 把连续的源代码字符串，拆分成一个个“有独立语义的最小单元”（Token）的过程。           |
| Lexer / Scanner              | 词法分析器/扫描器                                                       | 执行词法分析的程序（你的 `Lexer` 结构体及 `NextToken` 方法）。                     |
| Token (Lexical Unit)         | 词法单元/记号                                                           | 词法分析的输出，是“语义标签+内容”的组合（如 `token.Token{Type: INT, Literal: "42"}`）。 |
| Identifier (Ident)           | 标识符                                                                   | 用来命名的符号（变量名、函数名等，如 `x`、`add`），你的代码用 `isLetter` 函数识别。 |
| Literal                      | 字面量                                                                   | 直接表示具体值的符号（如 `42` 是整数字面量、`"hello"` 是字符串字面量），你的代码已支持 `INT` 字面量。 |
| Keyword                      | 关键字                                                                   | 语言内置的、有特殊语义的标识符（如 `let`、`fn`、`if`），你的代码用 `LookupIdent` 区分普通标识符和关键字。 |
| Punctuator / Separator       | 标点符号/分隔符                                                         | 语法结构中的“分隔/标记符号”（如 `;`、`{}`、`()`），你的代码中 `SEMICOLON`、`LBRACE` 等属于此类。 |
| Operator                     | 运算符                                                                   | 表示运算的符号（如 `+`、`=`、`!`），你的代码中 `PLUS`、`ASSIGN` 等属于此类。        |
| Whitespace                   | 空白字符                                                                 | 空格、制表符（`\t`）、换行（`\n`）等，不影响语法但分隔 Token，你的代码用 `skipWhitespace` 跳过。 |

## 三、语法分析阶段（Syntactic Analysis）
（核心是“验证 Token 序列是否符合语法规则”，是 Monkey 解释器下一步需实现的 `Parser` 功能）
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Syntactic Analysis / Parsing  | 语法分析/解析                                                           | 接收词法分析输出的 Token 序列，验证其是否符合语言的“语法规则”，并构建语法树的过程。 |
| Parser                       | 语法分析器                                                               | 执行语法分析的程序（Monkey 解释器下一步需实现的核心组件）。                         |
| Grammar                      | 语法                                                                     | 定义语言“合法结构”的规则（如“赋值语句 = 标识符 + = + 表达式 + ;”），通常用 BNF 或 EBNF 表示。 |
| BNF (Backus-Naur Form)       | 巴科斯-诺尔范式                                                         | 描述语法规则的标准格式（如 `assignment → ident "=" expression ";"`）。             |
| Abstract Syntax Tree (AST)   | 抽象语法树                                                               | 语法分析的核心输出，是“抽象化的语法结构”（忽略空格、分号等无关细节），每个节点对应一个语法成分（如赋值节点、表达式节点）。 |
| Syntax Error                 | 语法错误                                                                 | Token 序列违反语法规则（如 `let x = ;` 缺少表达式、`(x + y` 缺少右括号）。          |

## 四、语义分析阶段（Semantic Analysis）
（核心是“检查代码的逻辑合理性”，比语法分析更深一层）
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Semantic Analysis            | 语义分析                                                                 | 对 AST 进行检查，确保代码“有意义”（语法正确但逻辑可能错误）。                     |
| Semantic Error               | 语义错误                                                                 | 语法正确但逻辑不合理（如变量未定义就使用、整数和字符串相加、函数参数类型不匹配）。 |
| Type Checking                | 类型检查                                                                 | 验证操作数的类型是否符合运算要求（如 `1 + "2"` 在强类型语言中是错误）。             |
| Symbol Table                 | 符号表                                                                   | 存储标识符（变量、函数等）的关键信息（名称、类型、作用域、绑定的值），语义分析时用来查询标识符合法性。 |
| Scope                        | 作用域                                                                   | 标识符的“有效范围”（如局部变量只在函数内有效、全局变量整个程序有效）。             |

## 五、优化与代码生成阶段
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Optimization                 | 优化                                                                     | 对 IR 或 AST 进行修改，在不改变代码功能的前提下，提升运行效率（如删除无用代码、循环优化）。 |
| Code Generation              | 代码生成                                                                 | 把优化后的 IR 或 AST 翻译成目标代码（如机器码、字节码）的过程（编译器后端核心工作）。 |
| Constant Folding             | 常量折叠                                                                 | 优化技术之一：编译时计算常量表达式的值（如 `2 + 3` 直接替换为 `5`，无需运行时计算）。 |
| Garbage Collection (GC)      | 垃圾回收                                                                 | 自动回收程序中“不再使用的内存”（如 Java、Go、Python 都有 GC，C/C++ 需手动释放）。  |

## 六、其他基础补充
| 英文术语                     | 中文解释                                                                 | 通俗类比/关联代码                                                                 |
|------------------------------|--------------------------------------------------------------------------|----------------------------------------------------------------------------------|
| Static Typing                | 静态类型                                                                 | 编译时就确定变量类型（如 Java、C++），类型错误编译不通过。                         |
| Dynamic Typing               | 动态类型                                                                 | 运行时才确定变量类型（如 Python、JavaScript、Monkey 解释器），类型错误运行时才报错。 |
| Strong Typing                | 强类型语言                                                               | 不允许隐式类型转换（如 Python 中 `1 + "2"` 报错）。                                 |
| Weak Typing                  | 弱类型语言                                                               | 允许隐式类型转换（如 JavaScript 中 `1 + "2"` 结果为 `"12"`）。                      |
| Bytecode                     | 字节码                                                                   | 介于高级语言和机器码之间的“中间代码”（如 Java 字节码、Python 字节码），需虚拟机（VM）解释执行。 |
| Virtual Machine (VM)         | 虚拟机                                                                   | 执行字节码的“虚拟计算机”（如 JVM、Python VM），屏蔽硬件差异，实现跨平台。          |

---

### 核心流程串联（结合 Monkey 解释器）
`Source Code（let x = 42 + add(3);）`  
→ 「Lexical Analysis」→ `Token 序列（LET, IDENT(x), ASSIGN, INT(42), PLUS, IDENT(add), LPAREN, INT(3), RPAREN, SEMICOLON）`  
→ 「Parsing」→ `AST（赋值节点、加法表达式节点、函数调用节点）`  
→ 「Semantic Analysis」（检查 `x` 是否定义、`add` 是否为函数、参数类型是否匹配）  
→ 「Execution」（解释执行 AST，输出结果）

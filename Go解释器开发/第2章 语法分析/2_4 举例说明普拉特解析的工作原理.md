以`1+2*3`为例，会构造如下的AST


工作流程
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209113520066.png)

`1+2*3;`会被词法分析器分解成如下词法单元token
```GO
INT(1)-->PLUS(+)-->INT(2)-->ASTERISK(*)-->INT(3)-->SEMICOLON(;)
```
此时的token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
代码的核心是parseExpression函数和parseInfixExpression函数
```go
// 解析表达式 普卡特语法解析器核心 1+2*3
func (p *Parser) parseExpression(precedence int) ast.Expression {
	// 第一步：找当前token对应的「前缀解析函数」
	prefix := p.prefixParseFns[p.curToken.Type]
	//当前token：1，注册前缀解析函数prefix也就是parseIntegerLiteral()
	// 第二步：如果没有对应的前缀解析函数，报错并返回nil
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}

	// 第三步：执行前缀解析函数，得到表达式的「左部分」
	leftExp := prefix()
	// 执行parseIntegerLiteral()，leftExp = &ast.IntegerLiteral{Value: 1}
	// 此时 token 状态：curToken=INT(1)，peekToken=PLUS(+)

	// 第四步：循环解析「中缀表达式」（核心循环，处理优先级）左结合
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		// p.peekToken.Type = PLUS(+) → 拿到 parseInfixExpression 函数
		// infix = parseInfixExpression

		// 如果没有中缀解析函数，说明表达式结束，返回当前的左部分
		if infix == nil {
			return leftExp
		}
		// infix不为空跳过

		// 移动token
		p.nextToken()
		// 执行后 token 状态：curToken=PLUS(+)，peekToken=INT(2)

		// 执行中缀解析函数（核心递归），更新左部分为「完整的中缀表达式」
		leftExp = infix(leftExp)
		// 传入 leftExp=1，执行 parseInfixExpression(1)
	}

	// 第五步：返回最终解析好的表达式
	return leftExp //调用该解析函数
}

// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  //记录当前词法单元+的优先级 SUM
	p.nextToken()                                    //curToken=INT(2)，peekToken=ASTERISK(*)
	expression.Right = p.parseExpression(precedence) //递归调用 parseExpression(SUM) 解析右边的 2*3（重点！）

	return expression
}
```
解析的入口是parseExpression函数,当前状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)


## 第一步 处理数字1
`prefix := p.prefixParseFns[p.curToken.Type]`这句，注册INT(1)的前缀解析函数
`prefix=p.registerPrefix(token.INT, p.parseIntegerLiteral)`也就是prefix等于如下函数
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```

接着判断prefix是否为空，空则记录错误，返回空。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

执行解析函数`leftExp := prefix()`，执行解析函数，即左半部分`leftExp=1`。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
leftExp结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)

## 第二步 处理加号+
进入循环判断，循环的条件是`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`。即当前的下一个词法单元curToken类型不是分号(;)和当前优先级小于下一个词法单元的优先级，此间会调用`peekPrecedence()`函数获取`peekToken`的优先级
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
据图可见，当前的`curToken(1)`的优先级`precedence=1`小于`peekToken(+)`的优先级3，故而循环执行

### 2.1 获取中缀函数+移动token
获取注册函数`infix := p.infixParseFns[p.peekToken.Type]`，也就是+对应的中缀解析函数infix也就是`parseInfixExpression(left ast.Expression) ast.Expression`

```go
if infix == nil {
	return leftExp
}
```
如果没有对应的函数，则返回左半部分`leftExp=1`，结束循环，有的话则不返回，继续执行。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

向后移动。`p.nextToken()`。此时token发生改变
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
### 2.2 执行parseInfixExpression（处理 + 的右边）
执行解析函数`leftExp = infix(leftExp)`，执行前leftExp为1，对应结构体
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)
执行，也就是`leftExp=parseInfixExpression(left ast.Expression)`
执行parseInfixExpression(left ast.Expression)`
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  //记录当前词法单元+的优先级 SUM
	p.nextToken()                                    //curToken=INT(2)，peekToken=ASTERISK(*)
	expression.Right = p.parseExpression(precedence) //递归调用 parseExpression(SUM) 解析右边的 2*3（重点！）

	return expression
}
```
注意
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
故而，expression结构体
```go
expression := &ast.InfixExpression{
		Token:    p.curToken(+),         
		Operator: "+", 
		Left:     1,               
	}
```
此时，expression的结构体如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209122704827.png)
继续向下`precedence := p.curPrecedence()`记录当前token的优先级，即precedence=3

`p.nextToken()`移动token，新状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)

添加expression的右部分`expression.Right = p.parseExpression(precedence)`
此时又会调用parseExpression()函数

第九步
继续调用parseExpression()函数，此时precedence=3，token如下
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
让我们再次回到parseExpression()函数中
注册curToken的解析函数`prefix := p.prefixParseFns[p.curToken.Type]`，也就是
`prefix=p.registerPrefix(token.INT, p.parseIntegerLiteral)`也就是prefix等于如下函数
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```

再往下
```go
if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
```
此不执行

执行解析函数`leftExp := prefix()`
即现在的leftExp的结构体：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209123237071.png)
此时的token状态：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
好了又到了循环的环节了`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`，precedence=3，而peekToken的优先级为4。故而循环继续执行

第十步 
新的循环
```go
for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		infix := p.infixParseFns[p.peekToken.Type]
	
		if infix == nil {
			return leftExp
		}
	
		p.nextToken()
		leftExp = infix(leftExp)
		
	}
```
注册解析函数：
`infix := p.infixParseFns[p.peekToken.Type]`，即infix=parseInfixExpression(left ast.Expression) ast.Expression，也就是* 的中缀解析函数
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //2
		Operator: p.curToken.Literal, //2
		Left:     left,               //2
	}

	precedence := p.curPrecedence()                  //记录当前词法单元1的优先级 1
	p.nextToken()                                    //curToken=INT(2)，peekToken=ASTERISK(*)
	expression.Right = p.parseExpression(precedence) //递归调用 parseExpression(SUM) 解析右边的 2*3（重点！）

	return expression
}
```
precedence=1

token后移，新token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209124701404.png)
再此调用parseExpression(precedence)函数

第十一步
再次调用parseExpression(precedence)函数，此时precedence=1，当前token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209124701404.png)

注册解析函数`prefix := p.prefixParseFns[p.curToken.Type]`，但是没有对应的解析函数函数，返回空

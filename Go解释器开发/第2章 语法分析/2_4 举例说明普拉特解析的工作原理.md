以`1+2*3`为例，会构造如下的AST
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141044492.png)
## 前期工作
工作流程
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209113520066.png)

`1+2*3;`会被词法分析器分解成如下词法单元token
```GO
INT(1)-->PLUS(+)-->INT(2)-->ASTERISK(*)-->INT(3)-->SEMICOLON(;)
```
此时的token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
优先级表：
```go
// 解析优先级
const (
	_ int = iota
	LOWEST
	EQUALS      //==
	LESSGREATER //> or <
	SUM         //+
	PRODUCT     //*
	PREFIX      //-X or !x
	CALL        //函数func
)

// 优先级表
var precedences = map[token.TokenType]int{
	token.EQ:       EQUALS,
	token.NOT_EQ:   EQUALS,
	token.LT:       LESSGREATER,
	token.GT:       LESSGREATER,
	token.PLUS:     SUM, //+
	token.MINUS:    SUM, //-
	token.SLASH:    PRODUCT,
	token.ASTERISK: PRODUCT,
}
```
核心代码讲解：
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {

	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  // 获取当前运算符（如+/*）的优先级
	
	// 关键：移动token至右侧表达式的起始位置（如+→2，*→3）
    // 目的：让后续parseExpression从右侧第一个token开始解析（如2或3）
	p.nextToken()
	// 递归解析右侧表达式：传入当前运算符优先级作为基准，保证高优先级先解析                                  
	expression.Right = p.parseExpression(precedence) //递归入口：处理当前运算符+右侧表达式 第三步递归进入点，返回值对应第四步
	return expression
}
```
中缀解析函数，天生适合用来解析


```go
//parseExpression是普拉特解析器的核心之一
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp := prefix()//// 执行前缀解析函数：解析数字/布尔值等基础字面量，作为表达式左值
	
	// 循环核心规则：
	// 1. !p.peekTokenIs(token.SEMICOLON)：下一个token不是分号，说明表达式未结束
	// 2. precedence < p.peekPrecedence()：当前基准优先级 < 下一个运算符的优先级
	//    → 只有下一个运算符优先级更高，才继续解析（保证高优先级运算符先结合，如*先于+解析）
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		
		leftExp = infix(leftExp) //递归入口：处理当前运算符+右侧表达式 对应2.2 curToken=INT(1)，peekToken=PLUS(+)
	}

	
	return leftExp 
}
```

parseExpression是普拉特解析器的核心之一，它首先根据目前词法单元curToken的优先级，匹配对应的解析函数，没有的话就不执行。有的话就将解析出来的值作为表达式符号的左边的部分leftExp。好了现在有左半部分了，接着就需要右半部分的符号和表达式了。首先，右边第一位也就是peekToken必须是个运算符如加减乘除了，不能为分号，且优先级必须大于当前的优先级，否则没法向右进行。紧接着，就需要调用中缀解析函数了。




## 第一步 处理数字1
parseExpression函数如下
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp := prefix()//// 执行前缀解析函数：解析数字/布尔值等基础字面量，作为表达式左值
	
	// 循环核心规则：
	// 1. !p.peekTokenIs(token.SEMICOLON)：下一个token不是分号，说明表达式未结束
	// 2. precedence < p.peekPrecedence()：当前基准优先级 < 下一个运算符的优先级
	//    → 只有下一个运算符优先级更高，才继续解析（保证高优先级运算符先结合，如*先于+解析）
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		
		leftExp = infix(leftExp) //递归入口：处理当前运算符+右侧表达式 对应2.2 curToken=INT(1)，peekToken=PLUS(+)
	}

	
	return leftExp 
}
```

**这个循环是普拉特解析处理运算符优先级的核心 —— 只有当下一个运算符（如`*`）的优先级高于当前基准优先级（如`+`的 SUM=3）时，才会先递归解析下一个运算符的完整表达式，从而实现‘先乘除后加减’的运算规则。**

**初始调用：parseExpression(LOWEST) → 解析1**
`prefix := p.prefixParseFns[p.curToken.Type]`这句，注册INT(1)的==前缀解析函数==`prefix:=p.registerPrefix(token.INT, p.parseIntegerLiteral)`，==解析数字/布尔值等基础字面量，作为表达式左值==。

接着判断prefix是否为空，空则记录错误，返回空。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

执行解析函数`leftExp := prefix()`，执行解析函数，
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```
即左半部分`leftExp=1`。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
leftExp结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)

## 第二步 处理加号+
进入循环判断，循环的条件是`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`。即下一个词法单元peekToken类型不是分号(;)和当前优先级小于下一个词法单元的优先级，此间会调用`peekPrecedence()`函数获取`peekToken`的优先级。
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
据图可见，优先级precedence=1小于`peekToken(+)`的优先级3，故而循环执行

### 2.1 获取中缀函数+移动token
==获取==注册函数`infix := p.infixParseFns[p.peekToken.Type]`，也就是+对应的==中缀解析函数==infix也就是`parseInfixExpression(left ast.Expression) ast.Expression`，==匹配运算符（+/ * ）对应的解析逻辑，处理二元表达式==

```go
if infix == nil {
	return leftExp
}
```
如果没有对应的函数，则==返回左半部分`leftExp=1`，递归回溯时，将内层高优先级表达式（如2 * 3）作为外层运算符（+）的右值== 结束循环，有的话则不返回，继续执行。此时token状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

向后移动。`p.nextToken()`。移动token到下一个表达式。移动后token状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
### 2.2 执行parseInfixExpression（处理 + 的右边）
执行解析函数`leftExp = infix(leftExp)`，执行前leftExp为1，对应树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)
执行，也就是`leftExp=parseInfixExpression(left ast.Expression)`

执行parseInfixExpression(left ast.Expression)`
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {

	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  // 获取当前运算符（如+/*）的优先级
	
	// 关键：移动token至右侧表达式的起始位置（如+→2，*→3）
    // 目的：让后续parseExpression从右侧第一个token开始解析（如2或3）
	p.nextToken()
	// 递归解析右侧表达式：传入当前运算符优先级作为基准，保证高优先级先解析                                  
	expression.Right = p.parseExpression(precedence) //递归入口：处理当前运算符+右侧表达式 第三步递归进入点，返回值对应第四步
	return expression
}
```
**p.nextToken() 不是无意义的 token 移动，而是将解析指针精准定位到当前运算符右侧表达式的第一个 token（比如处理+时，移动后指向2；处理 * 时，移动后指向3），为后续递归解析右侧表达式铺路。**
此时的token状态为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
故而，加号(+)对应的expression结构体
```go
expression := &ast.InfixExpression{
		Token:    p.curToken(+),         
		Operator: "+", 
		Left:     1,               
	}
```
其树结构为
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141521941.png)
继续向下`precedence := p.curPrecedence()`记录当前token的优先级，即precedence=SUM(3)

`p.nextToken()`移动token，新token状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)

递归解析右边的`2*3`
`expression.Right = p.parseExpression(SUM)`

## 第三步 递归解析2 * 3 
### 3.1解析数字2
**第一层递归：parseExpression(SUM) → 解析2**
继续调用parseExpression()函数，此时precedence=SUM(3)，
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp_2 := prefix()
	
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp_2//带数字后缀是为区分层次
		}
		
		p.nextToken()
		
		leftExp_2 = infix(leftExp_2)//递归入口：处理当前运算符*右侧表达式 带数字后缀是为区分层次 curToken=INT(2) peekToken=ASTERISK(*)
	}

	
	return leftExp_2 
}
```


此时token状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
让我们再次回到parseExpression()函数中
注册curToken的解析函数`prefix := p.prefixParseFns[p.curToken.Type]`，也就是
`prefix=p.registerPrefix(token.INT, p.parseIntegerLiteral)`

再往下
```go
if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
```
有函数，不执行

执行解析函数`leftExp_2 := prefix()`
即现在的leftExp_2的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209123237071.png)
此时的token状态：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
好了又到了循环的环节了`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`，precedence=3，而peekToken的优先级为4。故而循环继续执行

### 3.2 进入中缀循环 处理* 
新的循环
```go
for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		infix := p.infixParseFns[p.peekToken.Type]
	
		if infix == nil {
			return leftExp
		}
	
		p.nextToken()
		leftExp_2 = infix(leftExp_2)//递归入口：处理当前运算符*右侧表达式 带数字后缀是为区分层次 curToken=INT(2) peekToken=ASTERISK(*)
		
	}
```
**这个循环是普拉特解析处理运算符优先级的核心 —— 只有当下一个运算符（*）的优先级高于当前基准优先级（如+的 SUM=3）时，先递归解析下一个运算符的完整表达式，从而实现‘先乘除后加减’的运算规则。**
#### 3.2.1 注册中缀解析函数
`infix := p.infixParseFns[p.peekToken.Type]`，即infix=parseInfixExpression(left ast.Expression) ast.Expression，也就是* 的中缀解析函数
#### 3.2.2 移动token
移动后token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209124701404.png)
#### 3.2.3 执行中缀解析函数
`leftExp_2 = infix(leftExp_2)`也就是parseInfixExpression(leftExp_2)
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	expression_2 := &ast.InfixExpression{//带数字后缀是为区分层次 此为乘号对应的expression
		Token:    p.curToken,         
		Operator: p.curToken.Literal, 
		Left:     left,               
	}

	precedence := p.curPrecedence()                  
	p.nextToken()                                    
	expression_2.Right = p.parseExpression(precedence) //返回值对应3.4 带数字后缀是为区分层次 curToken=ASTERISK(*) peekToken=INT(3)
	return expression_2
}
```
 初始化中缀节点，此为乘号对应的expression
```go
expression_2 := &ast.InfixExpression{
    Token:    curToken(*),
    Operator: "*",
    Left:     2,
}
```
此时它对应的树的结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141813699.png)

获取优先级`precedence = PRODUCT(4)`
移动后token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209132922287.png)
### 3.3 解析数字3

**第二层递归：parseExpression(PRODUCT) → 解析3**
调用parseExpression(PRODUCT)
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp_3 := prefix()//带数字后缀是为区分层次
	
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		leftExp_3 = infix(leftExp_3)//带数字后缀是为区分层次 curToken=ASTERISK(*) peekToken=INT(3)
	}

	return leftExp_3 
}
```
注册解析函数`prefix := p.prefixParseFns[INT]`，也就是parseIntegerLiteral函数
执行解析函数`leftExp_3 := prefix()`返回3的节点
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```
此时优先级`precedence = PRODUCT(4)`，peekToken=分号并且PRODUCT(4)<peekPrecedence()，不执行循环，返回`leftExp_3=3`

### 3.4 返回2 * 3的中缀节点

```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	expression_2 := &ast.InfixExpression{//此处是做区分
		Token:    p.curToken,         
		Operator: p.curToken.Literal, 
		Left:     left,               
	}

	precedence := p.curPrecedence()                  
	p.nextToken()                                    
	expression_2.Right = p.parseExpression(precedence) //返回值对应3.4
	return expression_2
}
```
此时，parseExpression()执行完毕，`expression_2.Right=3`，返回expression2，即：
```go
&ast.InfixExpression{Left:2, Operator:"*", Right:3}
```
此时`leftExp_2 = 2 * 3`的节点  。进行循环检查，peekToken=分号中止循环，返回leftExp_2=2 * 3。此时对应的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141921440.png)

## 第四步 拼接最终式
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {

	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  
	p.nextToken()                                    
	expression.Right = p.parseExpression(precedence) //第三步递归进入点，返回值对应第四步

	return expression
}
```
回到+的parseInfixExpression中：
`expression.Right=2 * 3`
最终返回：
```go
&ast.InfixExpression{
    Left:     1,
    Operator: "+",
    Right:    &ast.InfixExpression{Left:2, Operator:"*", Right:3},
}
```
对应的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141044492.png)

用栈的角度看待递归与回溯
```go
初始调用：parseExpression(LOWEST) → 解析1
第一层递归：parseExpression(SUM) → 解析2
第二层递归：parseExpression(PRODUCT) → 解析3
回溯：返回3 → 拼接2*3 → 返回2*3 → 拼接1+2*3
```
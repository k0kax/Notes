以`1+2*3`为例，会构造如下的AST


`1+2*3;`会被词法分析器分解成如下词法单元token
```GO
INT(1)-->PLUS(+)-->INT(2)-->ASTERISK(*)-->INT(3)-->SEMICOLON(;)
```

代码的核心是parseExpression函数和parseInfixExpression函数
```go
// 解析表达式 普卡特语法解析器核心 1+2*3
func (p *Parser) parseExpression(precedence int) ast.Expression {
	// 第一步：找当前token对应的「前缀解析函数」
	prefix := p.prefixParseFns[p.curToken.Type]
	//当前token：1，注册前缀解析函数prefix也就是parseIntegerLiteral()
	// 第二步：如果没有对应的前缀解析函数，报错并返回nil
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}

	// 第三步：执行前缀解析函数，得到表达式的「左部分」
	leftExp := prefix()
	// 执行parseIntegerLiteral()，leftExp = &ast.IntegerLiteral{Value: 1}
	// 此时 token 状态：curToken=INT(1)，peekToken=PLUS(+)

	// 第四步：循环解析「中缀表达式」（核心循环，处理优先级）左结合
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		// p.peekToken.Type = PLUS(+) → 拿到 parseInfixExpression 函数
		// infix = parseInfixExpression

		// 如果没有中缀解析函数，说明表达式结束，返回当前的左部分
		if infix == nil {
			return leftExp
		}
		// infix不为空跳过

		// 移动token
		p.nextToken()
		// 执行后 token 状态：curToken=PLUS(+)，peekToken=INT(2)

		// 执行中缀解析函数（核心递归），更新左部分为「完整的中缀表达式」
		leftExp = infix(leftExp)
		// 传入 leftExp=1，执行 parseInfixExpression(1)
	}

	// 第五步：返回最终解析好的表达式
	return leftExp //调用该解析函数
}

// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  //记录当前词法单元+的优先级 SUM
	p.nextToken()                                    //curToken=INT(2)，peekToken=ASTERISK(*)
	expression.Right = p.parseExpression(precedence) //递归调用 parseExpression(SUM) 解析右边的 2*3（重点！）

	return expression
}
```
解析的入口是parseExpression函数,当前状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209105740674.png)


第一步
`prefix := p.prefixParseFns[p.curToken.Type]`这句，注册INT(1)的前缀解析函数
`prefix=p.registerPrefix(token.INT, p.parseIntegerLiteral)`也就是prefix等于如下函数
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```

第二步
接着判断prefix是否为空，空则记录错误，返回空。

第三步
执行解析函数`leftExp := prefix()`，即`leftExp={}`


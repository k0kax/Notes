以`1+2*3`为例，会构造如下的AST
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141044492.png)
## 前期工作

工作流程
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209113520066.png)

`1+2*3;`会被词法分析器分解成如下词法单元token
```GO
INT(1)-->PLUS(+)-->INT(2)-->ASTERISK(*)-->INT(3)-->SEMICOLON(;)
```
此时的token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
代码的核心是parseExpression函数和parseInfixExpression函数
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  
	p.nextToken()                                    
	expression.Right = p.parseExpression(precedence) 
	return expression
}
```
解析的入口是parseExpression函数,当前状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
parseExpression函数如下
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp := prefix()
	
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		
		leftExp = infix(leftExp) //2.2 递归进入点
	}

	
	return leftExp 
}
```
## 第一步 处理数字1
`prefix := p.prefixParseFns[p.curToken.Type]`这句，注册INT(1)的前缀解析函数`prefix:=p.registerPrefix(token.INT, p.parseIntegerLiteral)`

接着判断prefix是否为空，空则记录错误，返回空。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

执行解析函数`leftExp := prefix()`，执行解析函数，
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```
即左半部分`leftExp=1`。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
leftExp结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)

## 第二步 处理加号+
进入循环判断，循环的条件是`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`。即当前的下一个词法单元curToken类型不是分号(;)和当前优先级小于下一个词法单元的优先级，此间会调用`peekPrecedence()`函数获取`peekToken`的优先级
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)
据图可见，当前的`curToken(1)`的优先级`precedence=1`小于`peekToken(+)`的优先级3，故而循环执行

### 2.1 获取中缀函数+移动token
获取注册函数`infix := p.infixParseFns[p.peekToken.Type]`，也就是+对应的中缀解析函数infix也就是`parseInfixExpression(left ast.Expression) ast.Expression`

```go
if infix == nil {
	return leftExp
}
```
如果没有对应的函数，则返回左半部分`leftExp=1`，结束循环，有的话则不返回，继续执行。此时
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209114055874.png)

向后移动。`p.nextToken()`。此时token发生改变
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
### 2.2 执行parseInfixExpression（处理 + 的右边）
执行解析函数`leftExp = infix(leftExp)`，执行前leftExp为1，对应树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209120641576.png)
执行，也就是`leftExp=parseInfixExpression(left ast.Expression)`
执行parseInfixExpression(left ast.Expression)`
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	// 1. 初始化中缀表达式节点（+）
	expression := &ast.InfixExpression{
		Token:    p.curToken,         //+
		Operator: p.curToken.Literal, //“+”
		Left:     left,               //1
	}

	precedence := p.curPrecedence()                  //
	p.nextToken()                                    //
	expression.Right = p.parseExpression(precedence) //第三步递归进入点，返回值对应第四步

	return expression
}
```
此时的token状态为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209115717281.png)
故而，expression结构体
```go
expression := &ast.InfixExpression{
		Token:    p.curToken(+),         
		Operator: "+", 
		Left:     1,               
	}
```
其树结构为
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141521941.png)
继续向下`precedence := p.curPrecedence()`记录当前token的优先级，即precedence=SUM(3)

`p.nextToken()`移动token，新token状态如下：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)

递归解析右边的`2*3`
`expression.Right = p.parseExpression(SUM)`

## 第三步 递归解析2 * 3 
继续调用parseExpression()函数，此时precedence=SUM(3)，
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp_2 := prefix()
	
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		
		leftExp_2 = infix(leftExp_2)
	}

	
	return leftExp 
}
```
token如下
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
让我们再次回到parseExpression()函数中
注册curToken的解析函数`prefix := p.prefixParseFns[p.curToken.Type]`，也就是
`prefix=p.registerPrefix(token.INT, p.parseIntegerLiteral)`

再往下
```go
if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
```
此不执行

执行解析函数`leftExp_2 := prefix()`
即现在的leftExp_2的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209123237071.png)
此时的token状态：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209121531012.png)
好了又到了循环的环节了`!p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence()`，precedence=3，而peekToken的优先级为4。故而循环继续执行

### 3.1 进入中缀循环 处理* 
新的循环
```go
for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		infix := p.infixParseFns[p.peekToken.Type]
	
		if infix == nil {
			return leftExp
		}
	
		p.nextToken()
		leftExp_2 = infix(leftExp_2)//此处是为区分
		
	}
```
#### 3.1.1 注册中缀解析函数
`infix := p.infixParseFns[p.peekToken.Type]`，即infix=parseInfixExpression(left ast.Expression) ast.Expression，也就是* 的中缀解析函数
#### 3.1.2 移动token
新token状态
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209124701404.png)
#### 3.1.3 执行中缀解析函数
`leftExp_2 = infix(leftExp_2)`也就是parseInfixExpression(leftExp_2)
```go
// 中缀解析函数
func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	expression_2 := &ast.InfixExpression{//此处是做区分
		Token:    p.curToken,         
		Operator: p.curToken.Literal, 
		Left:     left,               
	}

	precedence := p.curPrecedence()                  
	p.nextToken()                                    
	expression_2.Right = p.parseExpression(precedence) //返回值对应3.3
	return expression_2
}
```
 初始化中缀节点
```go
expression_2 := &ast.InfixExpression{
    Token:    curToken(*),
    Operator: "*",
    Left:     2,
}
```
此时它对应的树的结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141813699.png)

获取优先级`precedence = PRODUCT(4)`
移动token
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209132922287.png)
### 3.2 解析数字3
调用parseExpression(PRODUCT)
```go
func (p *Parser) parseExpression(precedence int) ast.Expression {
	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp_3 := prefix()//此处是为做区分
	
	for !p.peekTokenIs(token.SEMICOLON) && precedence < p.peekPrecedence() {
		
		infix := p.infixParseFns[p.peekToken.Type]
		
		if infix == nil {
			return leftExp
		}
		
		p.nextToken()
		leftExp_3 = infix(leftExp)
	}

	return leftExp_3 
}
```
注册解析函数`prefix := p.prefixParseFns[INT]`，也就是parseIntegerLiteral函数
执行解析函数`leftExp_3 := prefix()`返回3的节点
```go
// 解析函数：解析整形Int
func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}
```
此时优先级`precedence = PRODUCT(4)`，peekToken=分号并且PRODUCT(4<)peekPrecedence()，不执行循环，返回`leftExp_3=3`

### 3.3 返回2 * 3的中缀节点
此时`expression_2.Right=3`，返回
```go
&ast.InfixExpression{Left:2, Operator:"*", Right:3}
```
此时`leftExp_2 = 2 * 3`的节点  。进行循环检查，peekToken=分号中止循环，返回leftExp_2=2 * 3。此时对应的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141921440.png)

## 第四步 拼接最终式
回到+的parseInfixExpression中：
`expression.Right=2 * 2`
最终返回：
```go
&ast.InfixExpression{
    Left:     1,
    Operator: "+",
    Right:    &ast.InfixExpression{Left:2, Operator:"*", Right:3},
}
```
对应的树结构为：
![](https://raw.githubusercontent.com/k0kax/PicGo/main/images20251209141044492.png)
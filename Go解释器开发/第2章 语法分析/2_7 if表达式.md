if表达式就是条件转移的情况，示例如下：
```go
if(x>y){
	return x;
}esle{
	return y;	
}
```
当然else是可以省略的
```go
if(x>y){
	return x;
}
```
抽象可以表示为：
```go
if(<条件>)
<结果>
else
<可替代的结果>
```
此处并没有实现多条件的情况，也就是
```go
if(<条件1>)
<结果1>
else if(<条件2>)
<结果2>
else if(<条件3>)
<结果3>
...
else
<不符合任何条件的保底结果>
```

ast的构造
也就是if的表达式，可以将其分为条件condition，结果consequence，可替代结果alternative
```go
// ---------------------------------------------------if-else--------------------------------------------
type IfExpression struct {
	Token       token.Token
	Condition   Expression
	Consequence *BlockStatement
	Alternative *BlockStatement
}

func (ie *IfExpression) expressionNode()      {}
func (ie *IfExpression) TokenLiteral() string { return ie.Token.Literal }
func (ie *IfExpression) String() string {
	var out bytes.Buffer

	out.WriteString("if")
	out.WriteString(ie.Condition.String())
	out.WriteString(" ")
	out.WriteString(ie.Consequence.String())

	if ie.Alternative != nil {
		out.WriteString("else")
		out.WriteString(ie.Alternative.String())
	}

	return out.String()
}
```
其结果，可能含有多个语句，但要一块处理，特此需要设置成块，也就是Block
```go
type BlockStatement struct {
	Token      token.Token
	Statements []Statement
}

func (bs *BlockStatement) statementNode()       {}
func (bs *BlockStatement) TokenLiteral() string { return bs.Token.Literal }
func (bs *BlockStatement) String() string {
	var out bytes.Buffer

	for _, s := range bs.Statements {
		out.WriteString(s.String())
	}

	return out.String()
}
```
下一步就是看看解析器如何解析if
```go

```
第一步就是识别条件，

此处仅实现内置函数：len，用于返回字符串的长度
构建内置函数的对象
```go
// object.go
const (
	INTEGER_OBJ      = "INTEGER"      //整数
	BOOLEAN_OBJ      = "BOOLEAN"      //布尔
	NULL_OBJ         = "NULL"         //空值
	RETURN_VALUE_OBJ = "RETURN_VALUE" //返回值
	ERROR_OBJ        = "ERROR"        //错误
	FUNCTION_OBJ     = "FUNCTION"     //函数
	STRING_OBJ       = "STRING"       //字符串
	BUILTIN_OBJ      = "BUILTIN"      //内置函数
)

// 内置函数
type BuiltinFunction func(args ...Object) Object

type Builtin struct {
	Fn BuiltinFunction
}

func (b *Builtin) Type() ObjectType { return BOOLEAN_OBJ }
func (b *Builtin) Inspect() string  { return "builtin function" }
```
编写内置函数
```go
//builtin.go
package evaluator

import "monkey_Interpreter/object"

var builtins = map[string]*object.Builtin{
	"len": &object.Builtin{
		Fn: func(args ...object.Object) object.Object {
			if len(args) != 1 {
				return newError("wrong number of arguments. got=%d, want=1", len(args))
			}
			switch arg := args[0].(type) {
			case *object.String:
				return &object.Integer{Value: int64(len(arg.Value))}
			default:
				return newError("argument to 'len' not supported,got %s", args[0].Type())
			}
		},
	},
}
```
修改字面量求值函数
```go
// evaluator.go
func evalIdentifier(node *ast.Identifier, env *object.Environment) object.Object {
	//取环境绑定的值
	if val, ok := env.Get(node.Value); ok {
		return val
	}

	//如果没有绑定的值，则在内置函数环境中查找
	if builtin, ok := builtins[node.Value]; ok {
		return builtin
	}
	return newError("identifier not found:" + node.Value)
}
```

修改函数调用函数，以适应内置函数
```go
// evaluator.go

// 执行函数调用
func applyFunction(fn object.Object, args []object.Object) object.Object {

	switch fn := fn.(type) {
	case *object.Function: //自定义的函数
		extendedEnv := extendFunction(fn, args) //创建局部环境
		evaluated := Eval(fn.Body, extendedEnv) //执行函数，也就是配合环境执行函数体的内容
		return unwarpReturnValue(evaluated)     //解包，返回函数执行后的结果

	case *object.Builtin: //内置函数
		return fn.Fn(args...)

	default:
		return newError("not a function: %s", fn.Type())
	}
}
```